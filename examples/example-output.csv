TEST_ID|TIPO_PRUEBA|COMPONENTE|MODULO|REQUISITO_ID|DESCRIPCION|PRECONDICIONES|PASOS|RESULTADO_ESPERADO|PRIORIDAD|RIESGO|ETIQUETA_AUTOMATIZACION|ESTADO
TC_LOGIN_001|Unit|Auth|Login|REQ-001|Validar email formato RFC 5322|Función validateEmail() existe en codebase|1. Ejecutar validateEmail('valid@test.com') 2. Ejecutar validateEmail('invalid')|Retorna true para email válido, false para inválido|P1|Alto|@unit @auth @parallelizable|Generado
TC_LOGIN_002|Unit|Auth|Login|REQ-001|Validar password mínimo 8 caracteres|Función validatePassword() existe|1. Ejecutar validatePassword('short') 2. Ejecutar validatePassword('ValidPass123')|Retorna false para < 8 chars, true para ≥ 8|P1|Alto|@unit @auth @parallelizable|Generado
TC_LOGIN_003|Unit|Auth|Login|REQ-002|Generar JWT token correctamente|authService cargado, secret key configurado|1. Llamar generateToken({email: 'user@test.com', id: 1}) 2. Verificar payload|Token válido, payload contiene email+id, firma válida|P0|Alto|@unit @auth @parallelizable|Generado
TC_LOGIN_004|API|Auth|Login|REQ-001|POST /auth sin email retorna 400|API running localhost:3000, BD test|1. POST /auth con body {password: 'test'} 2. Capturar response|HTTP 400, JSON {error: 'email required'}|P0|Alto|@api @auth @parallelizable|Generado
TC_LOGIN_005|API|Auth|Login|REQ-001|POST /auth con email inválido retorna 400|API running, BD test|1. POST /auth con {email: 'invalid', password: 'test'} 2. Capturar response|HTTP 400, JSON {error: 'invalid email format'}|P1|Alto|@api @auth @parallelizable|Generado
TC_LOGIN_006|API|Auth|Login|REQ-001|POST /auth con credenciales válidas retorna 200|API running, BD test, user1@test.com existe|1. POST /auth {email: 'user1@test.com', password: 'ValidPass123'} 2. Capturar response|HTTP 200, JSON contiene token, token válido|P0|Alto|@api @auth @regression @parallelizable|Generado
TC_LOGIN_007|API|Auth|Login|REQ-001|POST /auth con credenciales inválidas retorna 401|API running, user existe|1. POST /auth {email: 'user1@test.com', password: 'WrongPassword'} 2. Capturar response|HTTP 401, JSON {error: 'invalid credentials'} genérico|P0|Alto|@api @auth @regression @parallelizable|Generado
TC_LOGIN_008|API|Auth|Login|REQ-001|Bloquear cuenta después 3 intentos fallidos|API running, user sin bloqueo|1. POST /auth con password incorrecto 3 veces en 1 min 2. Intento 4|HTTP 429, JSON {error: 'account locked for 15 minutes'}|P1|Alto|@api @auth @security|Generado
TC_LOGIN_009|Integration|Auth|Login|REQ-001,REQ-002|Backend genera token, frontend lo recibe|API running, frontend conectado a API|1. Frontend POST /auth 2. Capturar response 3. Validar token en localStorage|Token en response, localStorage actualizado, no errores en console|P0|Alto|@integration @auth|Generado
TC_LOGIN_010|E2E|Auth|Login|REQ-001,REQ-002|Flujo login completo navegación a dashboard|BD test activa, app running, user1@test.com existe|1. Navigate http://localhost:3000/login 2. Esperar carga 3. Ingresar email: user1@test.com 4. Ingresar password: ValidPass123 5. Click botón "Sign In" 6. Esperar 3s para redirect|Redirect a /dashboard, URL es /dashboard, status 200, no console errors, session cookie activa|P0|Alto|@e2e @auth @regression @smoke|Generado
TC_LOGIN_011|E2E|Auth|Login|REQ-001|Validación email vacío en frontend|App running, login page cargada|1. Navegar /login 2. Dejar email vacío 3. Dejar password con contenido 4. Click "Sign In"|Error message "Email es requerido" visible, form no submitido, foco en email|P1|Alto|@e2e @auth @regression|Generado
TC_LOGIN_012|E2E|Auth|Login|REQ-001|Validación password vacío en frontend|App running, login page cargada|1. Navegar /login 2. Ingresar email válido 3. Dejar password vacío 4. Click "Sign In"|Error message "Contraseña es requerida" visible, form no submitido|P1|Alto|@e2e @auth @regression|Generado
TC_LOGIN_013|E2E|Auth|Login|REQ-001|Link "Forgot Password" navega a reset|App running, login page cargada|1. Navegar /login 2. Buscar link "Forgot Password" 3. Click|Navega a /password-reset, URL /password-reset, página cargada|P2|Medio|@e2e @auth|Generado
TC_LOGIN_014|Smoke|Auth|Login|REQ-001,REQ-002|Login page carga sin errores|Server running|1. Navigate /login 2. Esperar 5s|Page loads, status 200, no 404, form visible, inputs present|P0|Medio|@smoke @auth @regression|Generado
TC_LOGIN_015|Security|Auth|Login|REQ-001|Resistencia a SQL injection|API running|1. POST /auth con email: "' OR '1'='1'; --" 2. Capturar response|HTTP 400 (invalid format), sin acceso BD, sin error SQL expuesto|P0|Alto|@security @auth|Generado
TC_LOGIN_016|Security|Auth|Login|REQ-001|Resistencia a credential stuffing|API running|1. Enviar 100 POST /auth en 10 segundos, mismo endpoint 2. Observar response|Primeros requests normal, luego HTTP 429 (rate limit), mensaje "Too many requests"|P1|Alto|@security @auth|Generado
TC_LOGIN_017|Accessibility|UI|Login|REQ-003|Form login cumple WCAG 2A|Login page cargada en navegador Chrome|1. Escanear /login con axe-core 2. Analizar violations|0 WCAG violations, todos inputs con labels, tab order correcto|P2|Medio|@a11y @wcag @auth|Generado
TC_LOGIN_018|Accessibility|UI|Login|REQ-003|Contraste de colores WCAG AA|Login form visible|1. Analizar contraste de texto vs fondo 2. Verificar ratio|Contraste mínimo 4.5:1 para texto normal, 3:1 para large text|P2|Medio|@a11y @wcag @auth|Generado
TC_LOGIN_019|Performance|API|Login|REQ-004|POST /auth responde < 200ms en red normal|API running, network normal|1. POST /auth 5 veces medir time 2. Calcular promedio|Response time promedio < 200ms, máximo 250ms|P2|Medio|@perf @api @auth|Generado
TC_LOGIN_020|Performance|E2E|Login|REQ-004|Login page carga en < 2s|App running, network normal|1. Navigate /login 2. Medir time hasta página interactiva|Time hasta interactive < 2s, Core Web Vitals OK|P2|Medio|@perf @e2e @auth|Generado
TC_LOGIN_021|Data Quality|Auth|Login|REQ-002|Token JWT tiene estructura válida|Token generado de login exitoso|1. Decodificar JWT (sin verificar firma) 2. Validar estructura|Header: {typ: 'JWT', alg: 'HS256'}, Payload: {email, id, iat, exp}, Signature presente|P1|Medio|@data-quality @auth|Generado
TC_LOGIN_022|Regression|E2E|Login|REQ-001,REQ-002|Login workflow no roto después cambio de código|App updated, BD reset|1. Ejecutar todos los pasos del flujo principal login|Todos los pasos exitosos como antes, no nuevos errores|P0|Alto|@regression @auth @smoke|Generado
